<template>
  <div class="h-lvh bg-gray-900 text-white mt-[80px] mb-[120px]">
    <!-- 頁面標題 -->
    <div class="w-full p-6 border-b border-gray-800 fixed top-0 bg-gray-900 z-10">
      <div class="flex items-center justify-between">
        <h1 class="text-3xl font-bold text-white">AI 對話</h1>
        <div class="flex items-center gap-4">
          <!-- 返回收藏頁面按鈕 -->
          <button
            @click="$router.back()"
            class="px-4 py-2 bg-gray-700 rounded-lg text-sm font-medium"
          >
            返回
          </button>
        </div>
      </div>
    </div>

    <!-- 聊天區域 -->
    <div class="flex-1 flex flex-col overflow-scroll h-full">
      <!-- 聊天記錄 -->
      <div ref="chatContainer" class="flex-1 p-6">
        <div
          v-for="(sentence, index) in selectedSentences"
          :key="sentence.id"
          class="bg-gray-800 rounded-lg p-3 border border-gray-700 flex items-start mb-2 gap-3"
        >
          <!-- 順序標示 -->
          <div
            class="w-6 h-6 bg-blue-500 text-white text-xs font-bold rounded-full flex items-center justify-center flex-shrink-0 mt-0.5"
          >
            {{ index + 1 }}
          </div>
          <!-- 句子內容 -->
          <p class="text-sm text-gray-200 flex-1 leading-relaxed">{{ sentence.text }}</p>
        </div>
        <!-- 訊息列表 -->
        <div class="space-y-4 max-w-4xl mx-auto">
          <div
            v-for="message in messages"
            :key="message.id"
            :class="['flex', message.role === 'user' ? 'justify-end' : 'justify-start']"
          >
            <div
              :class="[
                'max-w-[80%] rounded-lg p-4',
                message.role === 'user'
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-100 border border-gray-700',
              ]"
            >
              <div v-html="formatMessage(message.content)"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- 輸入區域 -->
    <div class="p-6 border-t border-gray-800 pb-[50px] fixed z-10 bottom-0 bg-gray-900">
      <div class="max-w-4xl mx-auto">
        <div class="flex gap-4">
          <textarea
            v-model="inputMessage"
            @keydown.enter.prevent="handleEnterKey"
            placeholder="輸入您的訊息..."
            class="flex-1 px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-400 resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            rows="1"
          ></textarea>
          <button
            @click="sendMessage"
            :disabled="!inputMessage.trim() || isLoading"
            class="px-6 py-3 bg-blue-600 text-white rounded-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
          >
            <svg
              v-if="isLoading"
              class="animate-spin w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
              />
            </svg>
            <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"
              />
            </svg>
            {{ isLoading ? '發送中...' : '發送' }}
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick, watch } from 'vue'
import { useFavoritesStore } from '@/stores/favorites'
import { useChatStore } from '@/stores/chat'
import { renderMarkdown } from '@/utils/markdown'

// Stores
const favoritesStore = useFavoritesStore()
const chatStore = useChatStore()

// 響應式變數
const inputMessage = ref('')
const isLoading = ref(false)
const isFirstMessage = ref(true) // 追蹤是否為第一次提問
const chatContainer = ref<HTMLElement | null>(null) // 聊天容器引用

// 計算屬性
const selectedSentences = computed(() => favoritesStore.selectedSentences)
const messages = computed(() => chatStore.messages)

// 格式化訊息 (支援 Markdown)
const formatMessage = (content: string): string => {
  return renderMarkdown(content)
}

// 滾動到底部
const scrollToBottom = async () => {
  await nextTick()
  if (chatContainer.value) {
    chatContainer.value.scrollTop = chatContainer.value.scrollHeight
  }
}

// 處理 Enter 鍵
const handleEnterKey = (event: KeyboardEvent) => {
  if (event.metaKey && event.key === 'Enter') {
    // Command + Enter：發送訊息
    event.preventDefault()
    sendMessage()
  }
  // 其他情況（包括單純的 Enter）：允許換行
}

// 發送訊息（使用串流）
const sendMessage = async () => {
  if (!inputMessage.value.trim() || isLoading.value) return

  const userMessage = inputMessage.value.trim()
  inputMessage.value = ''

  try {
    isLoading.value = true

    // 第一次提問時加上 startDiscussion，之後只送使用者輸入
    const messageToSend = isFirstMessage.value ? startDiscussion(userMessage) : userMessage

    // 使用 chatStore 的串流方法
    await chatStore.sendMessageStream(messageToSend)

    // 發送完第一次訊息後設為 false
    if (isFirstMessage.value) {
      isFirstMessage.value = false
    }

    // 發送訊息後滾動到底部
    await scrollToBottom()
  } catch (error) {
    console.error('AI 回覆失敗:', error)
    // 錯誤已由 chatStore 處理，這裡不需要額外處理
  } finally {
    isLoading.value = false
  }
}

// 開始討論選取的句子
const startDiscussion = (userMessage: string) => {
  if (selectedSentences.value.length === 0) return userMessage

  const sentences = selectedSentences.value
    .map((sentence, index) => `${index + 1}. "${sentence.text}"`)
    .join('\n')

  return `使用者選擇了這幾個句子：\n\n${sentences}\n\n 使用者：${userMessage}`
}

// 監聽訊息變化，自動滾動到底部
watch(
  () => messages.value.length,
  async () => {
    await scrollToBottom()
  },
  { flush: 'post' },
)

// 監聽訊息內容變化（串流更新時），自動滾動到底部
watch(
  () => messages.value.map((m) => m.content).join(''),
  async () => {
    await scrollToBottom()
  },
  { flush: 'post' },
)

// 頁面載入時清空聊天記錄並重置第一次提問狀態
onMounted(() => {
  chatStore.clearHistory()
  isFirstMessage.value = true
})
</script>
